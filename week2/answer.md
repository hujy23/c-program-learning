## 思考题答案：

| 类型          | 比特（位）数 | 取值范围                                     |
| ----------- | ------ | ---------------------------------------- |
| int         | 32     | -2147483648~2147483647 即 $-2^{31}$ ~ $(2^{31}-1)$ |
| short [int] | 16     | -32768~32767 即 $-2^{15}$ ~ $(2^{15}-1)$ |
| long [int]  | 32     | -2147483648~2147483647 即 $-2^{31}$ ~ $(2^{31}-1)$ |

注：省略了signed，视编译环境不同而不同，这里是VC

所以可以知道，当把2147483647赋给short int的时候，也就是把1个0、31个1赋给short int，只取了低16位。

简化一下举个例子。

| 补(原)码 | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 补码    | 舍弃   | 舍弃   | 舍弃   | 舍弃   | 1    | 1    | 1    | 1    |

计算机用的是补码，原码就是二进制形式加上符号位，正数的原码和补码是一样的，负数的话，把原码的符号位不变，其余位取反再加1就得到补码（求补码的简单记法，有时会带来困惑，不如第二种方法）。把8位正数 $2^7-1$ 赋给了4位的，符号位是1，是负数，所以先减1，然后符号位不变，其余按位取反得到原码，即为-1

| 反码   | 1    | 1    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- |
| 原码   | 1    | 0    | 0    | 1    |

![](./short%20int%20xiaoguo.png)

## 上机题答案：

2147483647 = 0111……1111（32位）

2147483647 + 1 = 1000……0000
 
而1000……0000就是-2147483648

求补码的第二种方式：

-2147483648 取绝对值 2147483648
 
二进制形式1000……0000（32位）（原码）
 
取反0111……1111
 
加一1000……0000（补码）
 
-2147483648 = -1000……0000（原） = 1000……0000（补）
 
这也是用补码的好处，补码0000……0000表示的是0，而补码1000……0000表示的是-2147483648，即表示范围为-2147483648到2147483647，即-2^31到2^31-1

另外，-2147483647的补码是1000……0001

![](./sizexiaoguo.png)

注：markdown语法中添加公式可以参考[这篇教程](http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/)或者[这篇](https://www.zybuluo.com/codeep/note/163962)，在本文中用的不多，就是一个{ }要注意，上标下标多以一个字符要加{ }括起来。
